
axiomatic Padding {

  logic type padding
  
}

tag voidP = {
}

type voidP = [voidP]

tag charP = voidP with {
  int8 charM: 8;
}

tag unsigned_charP = {
  uint8 unsigned_charM: 8;
}

type unsigned_charP = [unsigned_charP]

axiomatic generic_swap {

  predicate generic_swap{L1, L2}(charP[..] a, charP[..] b, integer size) =
  (\forall integer i_1;
    (((0 <= i_1) && (i_1 < size)) ==>
      ((\at((a + i_1).charM,L1) == \at((b + i_1).charM,L2)) &&
        (\at((b + i_1).charM,L1) == \at((a + i_1).charM,L2)))))
   
  lemma generic_swap_next{L1, L2} :
  (_C_1 : (\forall charP[..] a_0;
            (\forall charP[..] b_0;
              (\forall integer size_0;
                ((((\at((a_0 + (size_0 - 1)).charM,L1) ==
                     \at((b_0 + (size_0 - 1)).charM,L2)) &&
                    (\at((b_0 + (size_0 - 1)).charM,L1) ==
                      \at((a_0 + (size_0 - 1)).charM,L2))) &&
                   generic_swap{L1,
                   L2}(a_0, b_0, (size_0 - 1))) ==>
                  generic_swap{L1,
                  L2}(a_0, b_0, size_0))))))
   
  lemma generic_swap_zero{L1, L2} :
  (_C_2 : (\forall charP[..] a_1;
            (\forall charP[..] b_1;
              (\forall integer size_1;
                ((size_1 == 0) ==> generic_swap{L1, L2}(a_1, b_1, 0))))))
  
}

unit generic_swap(voidP[..] a, voidP[..] b, int32 size_0)
  requires ((_C_59 : (size_0 > (0 :> int32))) &&
             ((_C_60 : (a <: charP)) &&
               ((_C_61 : (b <: charP)) &&
                 ((_C_62 : \at((if (\at(0,Here) <=
                                     \at(((size_0 :> integer) - 1),Here)) then 
                               (((\offset_min(\at((a :> charP[..]),Here)) <=
                                   \at(0,Here)) &&
                                  (\offset_max(\at((a :> charP[..]),Here)) >=
                                    \at(((size_0 :> integer) - 1),Here))) &&
                                 (\forall integer __framac_tmp1;
                                   (((\at(0,Here) <= __framac_tmp1) &&
                                      (__framac_tmp1 <=
                                        \at(((size_0 :> integer) - 1),Here))) ==>
                                     true))) else true),Here)) &&
                   (_C_63 : \at((if (\at(0,Here) <=
                                      \at(((size_0 :> integer) - 1),Here)) then 
                                (((\offset_min(\at((b :> charP[..]),Here)) <=
                                    \at(0,Here)) &&
                                   (\offset_max(\at((b :> charP[..]),Here)) >=
                                     \at(((size_0 :> integer) - 1),Here))) &&
                                  (\forall integer __framac_tmp2;
                                    (((\at(0,Here) <= __framac_tmp2) &&
                                       (__framac_tmp2 <=
                                         \at(((size_0 :> integer) - 1),Here))) ==>
                                      true))) else true),Here))))));
behavior default:
  assigns ((a :> charP[..]) + [0..((size_0 :> integer) - 1)]).charM,
  ((b :> charP[..]) + [0..((size_0 :> integer) - 1)]).charM;
  ensures (_C_58 : generic_swap{Old,
          Here}((\at(a,Old) :> charP[..]), (\at(b,Old) :> charP[..]),
                (\at(size_0,Old) :> integer)));
{  
   (var int8 t);
   
   (var int32 osize);
   
   (var charP[..] oa);
   
   (var charP[..] ob);
   
   (var voidP[..] tmp);
   
   (var voidP[..] tmp_0);
   
   {  (_C_3 : (osize = size_0));
      (_C_5 : (oa = (_C_4 : (a :> charP[..]))));
      (_C_7 : (ob = (_C_6 : (b :> charP[..]))));
      (Loop : ());
      
      loop 
      behavior default:
        invariant (_C_34 : ((_C_35 : ((0 :> int32) <= size_0)) &&
                             (_C_36 : (size_0 <= osize))));
      behavior default:
        invariant (_C_33 : (a <: charP));
      behavior default:
        invariant (_C_32 : (b <: charP));
      behavior default:
        invariant (_C_25 : (((_C_27 : (\base_block(oa) ==
                                        \base_block((a :> charP[..])))) &&
                              (_C_28 : ((oa - (a :> charP[..])) <= 0))) &&
                             ((_C_30 : (\base_block((a :> charP[..])) ==
                                         \base_block((oa +
                                                       (osize :> integer))))) &&
                               (_C_31 : (((a :> charP[..]) -
                                           (oa + (osize :> integer))) <
                                          0)))));
      behavior default:
        invariant (_C_18 : (((_C_20 : (\base_block(ob) ==
                                        \base_block((b :> charP[..])))) &&
                              (_C_21 : ((ob - (b :> charP[..])) <= 0))) &&
                             ((_C_23 : (\base_block((b :> charP[..])) ==
                                         \base_block((ob +
                                                       (osize :> integer))))) &&
                               (_C_24 : (((b :> charP[..]) -
                                           (ob + (osize :> integer))) <
                                          0)))));
      behavior default:
        invariant (_C_15 : ((_C_16 : (((a :> charP[..]) - oa) ==
                                       ((b :> charP[..]) - ob))) &&
                             (_C_17 : (((b :> charP[..]) - ob) ==
                                        ((osize :> integer) -
                                          (size_0 :> integer))))));
      behavior default:
        invariant (_C_12 : ((_C_13 : (0 <=
                                       ((osize :> integer) -
                                         (size_0 :> integer)))) &&
                             (_C_14 : (((osize :> integer) -
                                         (size_0 :> integer)) <=
                                        (osize :> integer)))));
      behavior default:
        invariant (_C_11 : generic_swap{Here,
                  Pre}(oa, ob, ((osize :> integer) - (size_0 :> integer))));
      behavior default:
        invariant (_C_10 : (\forall charP[..] p;
                             ((((\base_block((a :> charP[..])) ==
                                  \base_block(p)) &&
                                 (((a :> charP[..]) - p) <= 0)) &&
                                ((\base_block(p) ==
                                   \base_block((oa + (osize :> integer)))) &&
                                  ((p - (oa + (osize :> integer))) < 0))) ==>
                               (p.charM == \at(p.charM,Pre)))));
      behavior default:
        invariant (_C_9 : (\forall charP[..] p_0;
                            ((((\base_block((b :> charP[..])) ==
                                 \base_block(p_0)) &&
                                (((b :> charP[..]) - p_0) <= 0)) &&
                               ((\base_block(p_0) ==
                                  \base_block((ob + (osize :> integer)))) &&
                                 ((p_0 - (ob + (osize :> integer))) < 0))) ==>
                              (p_0.charM == \at(p_0.charM,Pre)))));
      behavior default:
        
        assigns (oa + [0..((osize :> integer) - (size_0 :> integer))]).charM,
        (ob + [0..((osize :> integer) - (size_0 :> integer))]).charM;
      variant (_C_8 : size_0);
      while (true)
      {  
         {  
            {  (_C_39 : (t = (_C_38 : (_C_37 : (a :> charP[..])).charM)));
               
               {  (_C_40 : (tmp = a));
                  (_C_42 : (a = (_C_41 : (a + (1 :> int32)))));
                  (_C_47 : ((_C_46 : (_C_45 : (tmp :> charP[..])).charM) = 
                  (_C_44 : (_C_43 : (b :> charP[..])).charM)))
               };
               
               {  (_C_48 : (tmp_0 = b));
                  (_C_50 : (b = (_C_49 : (b + (1 :> int32)))));
                  (_C_53 : ((_C_52 : (_C_51 : (tmp_0 :> charP[..])).charM) = t))
               }
            };
            (_C_56 : (size_0 = (_C_55 : ((_C_54 : (size_0 - (1 :> int32))) :> int32))));
            (if (_C_57 : (size_0 > (0 :> int32))) then () else 
            (goto while_0_break))
         }
      };
      (while_0_break : ());
      
      (return ())
   }
}
